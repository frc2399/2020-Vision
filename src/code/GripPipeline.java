package code;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.HashMap;

import org.opencv.core.*;
import org.opencv.core.Core.*;
import org.opencv.features2d.FeatureDetector;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.*;
import org.opencv.objdetect.*;

/**
* GripPipeline class.
*
* <p>An OpenCV pipeline generated by GRIP.
*
* @author GRIP
*/
public class GripPipeline {
	
	//Outputs
		private Mat blurOutput = new Mat();
		private Mat hsvThresholdOutput = new Mat();
		private Mat cvErodeOutput = new Mat();
		private ArrayList<MatOfPoint> findContoursOutput = new ArrayList<MatOfPoint>();
		private ArrayList<MatOfPoint> convexHullsOutput = new ArrayList<MatOfPoint>();
		private ArrayList<MatOfPoint> filterContoursOutput = new ArrayList<MatOfPoint>();
		private Mat sourceOutput = new Mat();

		static {
			System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
		}

		/**
		 * This is the primary method that runs the entire pipeline and updates the outputs.
		 */
		public void process(Mat source0) {
			sourceOutput = source0;
			
			// Step Blur0:
			Mat blurInput = source0;
			BlurType blurType = BlurType.get("Median Filter");
			//double blurRadius = 7.207207207207207;
			double blurRadius = 3;
			blur(blurInput, blurType, blurRadius, blurOutput);

			// Step HSV_Threshold0:
			Mat hsvThresholdInput = blurOutput;
			double[] hsvThresholdHue = {0.0, 90.0};
			double[] hsvThresholdSaturation = {0.0, 255.0};
			double[] hsvThresholdValue = {254.5, 255.0};
			hsvThreshold(hsvThresholdInput, hsvThresholdHue, hsvThresholdSaturation, hsvThresholdValue, hsvThresholdOutput);

			
			// Step CV_erode0:
			Mat cvErodeSrc = hsvThresholdOutput;
			Mat cvErodeKernel = new Mat();
			Point cvErodeAnchor = new Point(-1, -1);
			double cvErodeIterations = 0.0;
			int cvErodeBordertype = Core.BORDER_CONSTANT;
			Scalar cvErodeBordervalue = new Scalar(-1);
			cvErode(cvErodeSrc, cvErodeKernel, cvErodeAnchor, cvErodeIterations, cvErodeBordertype, cvErodeBordervalue, cvErodeOutput);

			// Step Find_Contours0:
			Mat findContoursInput = cvErodeOutput;
			boolean findContoursExternalOnly = false;
			findContours(findContoursInput, findContoursExternalOnly, findContoursOutput);

			// Step Convex_Hulls0:
			ArrayList<MatOfPoint> convexHullsContours = findContoursOutput;
			convexHulls(convexHullsContours, convexHullsOutput);
			
			
			
			// Approximate Contours
			ArrayList<MatOfPoint> approxContours = approxContours(convexHullsOutput);
			
			// Step Filter_Contours0:
			ArrayList<MatOfPoint> filterContoursContours = approxContours;
			double filterContoursMinArea = 1.0;
			double filterContoursMinPerimeter = 1.0;
			double filterContoursMinWidth = 0.0;
			double filterContoursMaxWidth = 10000.0;
			double filterContoursMinHeight = 0.0;
			double filterContoursMaxHeight = 1000.0;
			double[] filterContoursSolidity = {0.0, 100.0};
			double filterContoursMaxVertices = 10.0;
			double filterContoursMinVertices = 4.0;
			double filterContoursMinRatio = 0.0;
			double filterContoursMaxRatio = 1000.0;
			filterContours(filterContoursContours, filterContoursMinArea, filterContoursMinPerimeter, filterContoursMinWidth, filterContoursMaxWidth, filterContoursMinHeight, filterContoursMaxHeight, filterContoursSolidity, filterContoursMaxVertices, filterContoursMinVertices, filterContoursMinRatio, filterContoursMaxRatio, filterContoursOutput);

			//print goal distance from camera
			
			System.out.println(findXAngle(findGoal(filterContoursOutput())));
			//System.out.println(focalLength(findGoal(filterContoursOutput())));
			//System.out.println(goalDistance(findGoal(filterContoursOutput())));
			//System.out.println(pixToInch(findGoalWidth(findGoal(filterContoursOutput())), goalDistance(findGoal(filterContoursOutput()))));
		
			
		}

		/**
		 * This method is a generated getter for the output of a Blur.
		 * @return Mat output from Blur.
		 */
		public Mat blurOutput() {
			return blurOutput;
		}

		/**
		 * This method is a generated getter for the output of a HSV_Threshold.
		 * @return Mat output from HSV_Threshold.
		 */
		public Mat hsvThresholdOutput() {
			return hsvThresholdOutput;
		}

		/**
		 * This method is a generated getter for the output of a CV_erode.
		 * @return Mat output from CV_erode.
		 */
		public Mat cvErodeOutput() {
			return cvErodeOutput;
		}

		/**
		 * This method is a generated getter for the output of a Find_Contours.
		 * @return ArrayList<MatOfPoint> output from Find_Contours.
		 */
		public ArrayList<MatOfPoint> findContoursOutput() {
			return findContoursOutput;
		}

		/**
		 * This method is a generated getter for the output of a Convex_Hulls.
		 * @return ArrayList<MatOfPoint> output from Convex_Hulls.
		 */
		public ArrayList<MatOfPoint> convexHullsOutput() {
			return convexHullsOutput;
		}

		/**
		 * This method is a generated getter for the output of a Filter_Contours.
		 * @return ArrayList<MatOfPoint> output from Filter_Contours.
		 */
		public ArrayList<MatOfPoint> filterContoursOutput() {
			return filterContoursOutput;
		}


		/**
		 * An indication of which type of filter to use for a blur.
		 * Choices are BOX, GAUSSIAN, MEDIAN, and BILATERAL
		 */
		enum BlurType{
			BOX("Box Blur"), GAUSSIAN("Gaussian Blur"), MEDIAN("Median Filter"),
				BILATERAL("Bilateral Filter");

			private final String label;

			BlurType(String label) {
				this.label = label;
			}

			public static BlurType get(String type) {
				if (BILATERAL.label.equals(type)) {
					return BILATERAL;
				}
				else if (GAUSSIAN.label.equals(type)) {
				return GAUSSIAN;
				}
				else if (MEDIAN.label.equals(type)) {
					return MEDIAN;
				}
				else {
					return BOX;
				}
			}

			@Override
			public String toString() {
				return this.label;
			}
		}

		/**
		 * Softens an image using one of several filters.
		 * @param input The image on which to perform the blur.
		 * @param type The blurType to perform.
		 * @param doubleRadius The radius for the blur.
		 * @param output The image in which to store the output.
		 */
		private void blur(Mat input, BlurType type, double doubleRadius,
			Mat output) {
			int radius = (int)(doubleRadius + 0.5);
			int kernelSize;
			switch(type){
				case BOX:
					kernelSize = 2 * radius + 1;
					Imgproc.blur(input, output, new Size(kernelSize, kernelSize));
					break;
				case GAUSSIAN:
					kernelSize = 6 * radius + 1;
					Imgproc.GaussianBlur(input,output, new Size(kernelSize, kernelSize), radius);
					break;
				case MEDIAN:
					kernelSize = 2 * radius + 1;
					Imgproc.medianBlur(input, output, kernelSize);
					break;
				case BILATERAL:
					Imgproc.bilateralFilter(input, output, -1, radius, radius);
					break;
			}
		}

		/**
		 * Segment an image based on hue, saturation, and value ranges.
		 *
		 * @param input The image on which to perform the HSL threshold.
		 * @param hue The min and max hue
		 * @param sat The min and max saturation
		 * @param val The min and max value
		 * @param output The image in which to store the output.
		 */
		private void hsvThreshold(Mat input, double[] hue, double[] sat, double[] val,
		    Mat out) {
			Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2HSV);
			Core.inRange(out, new Scalar(hue[0], sat[0], val[0]),
				new Scalar(hue[1], sat[1], val[1]), out);
		}

		/**
		 * Expands area of lower value in an image.
		 * @param src the Image to erode.
		 * @param kernel the kernel for erosion.
		 * @param anchor the center of the kernel.
		 * @param iterations the number of times to perform the erosion.
		 * @param borderType pixel extrapolation method.
		 * @param borderValue value to be used for a constant border.
		 * @param dst Output Image.
		 */
		private void cvErode(Mat src, Mat kernel, Point anchor, double iterations,
			int borderType, Scalar borderValue, Mat dst) {
			if (kernel == null) {
				kernel = new Mat();
			}
			if (anchor == null) {
				anchor = new Point(-1,-1);
			}
			if (borderValue == null) {
				borderValue = new Scalar(-1);
			}
			Imgproc.erode(src, dst, kernel, anchor, (int)iterations, borderType, borderValue);
		}

		/**
		 * Sets the values of pixels in a binary image to their distance to the nearest black pixel.
		 * @param input The image on which to perform the Distance Transform.
		 * @param type The Transform.
		 * @param maskSize the size of the mask.
		 * @param output The image in which to store the output.
		 */
		private void findContours(Mat input, boolean externalOnly,
			List<MatOfPoint> contours) {
			Mat hierarchy = new Mat();
			contours.clear();
			int mode;
			if (externalOnly) {
				mode = Imgproc.RETR_EXTERNAL;
			}
			else {
				mode = Imgproc.RETR_LIST;
			}
			int method = Imgproc.CHAIN_APPROX_SIMPLE;
			Imgproc.findContours(input, contours, hierarchy, mode, method);
		}

		/**
		 * Compute the convex hulls of contours.
		 * @param inputContours The contours on which to perform the operation.
		 * @param outputContours The contours where the output will be stored.
		 */
		private void convexHulls(List<MatOfPoint> inputContours,
			ArrayList<MatOfPoint> outputContours) {
			final MatOfInt hull = new MatOfInt();
			outputContours.clear();
			for (int i = 0; i < inputContours.size(); i++) {
				final MatOfPoint contour = inputContours.get(i);
				final MatOfPoint mopHull = new MatOfPoint();
				Imgproc.convexHull(contour, hull);
				mopHull.create((int) hull.size().height, 1, CvType.CV_32SC2);
				for (int j = 0; j < hull.size().height; j++) {
					int index = (int) hull.get(j, 0)[0];
					double[] point = new double[] {contour.get(index, 0)[0], contour.get(index, 0)[1]};
					mopHull.put(j, 0, point);
				}
				outputContours.add(mopHull);
			}
		}


		/**
		 * Filters out contours that do not meet certain criteria.
		 * @param inputContours is the input list of contours
		 * @param output is the the output list of contours
		 * @param minArea is the minimum area of a contour that will be kept
		 * @param minPerimeter is the minimum perimeter of a contour that will be kept
		 * @param minWidth minimum width of a contour
		 * @param maxWidth maximum width
		 * @param minHeight minimum height
		 * @param maxHeight maximimum height
		 * @param Solidity the minimum and maximum solidity of a contour
		 * @param minVertexCount minimum vertex Count of the contours
		 * @param maxVertexCount maximum vertex Count
		 * @param minRatio minimum ratio of width to height
		 * @param maxRatio maximum ratio of width to height
		 */
		private void filterContours(List<MatOfPoint> inputContours, double minArea,
			double minPerimeter, double minWidth, double maxWidth, double minHeight, double
			maxHeight, double[] solidity, double maxVertexCount, double minVertexCount, double
			minRatio, double maxRatio, List<MatOfPoint> output) {
			final MatOfInt hull = new MatOfInt();
			output.clear();
			//operation
			for (int i = 0; i < inputContours.size(); i++) {
				final MatOfPoint contour = inputContours.get(i);
				final Rect bb = Imgproc.boundingRect(contour);
				if (bb.width < minWidth || bb.width > maxWidth) continue;
				if (bb.height < minHeight || bb.height > maxHeight) continue;
				final double area = Imgproc.contourArea(contour);
				if (area < minArea) continue;
				if (Imgproc.arcLength(new MatOfPoint2f(contour.toArray()), true) < minPerimeter) continue;
				Imgproc.convexHull(contour, hull);
				MatOfPoint mopHull = new MatOfPoint();
				mopHull.create((int) hull.size().height, 1, CvType.CV_32SC2);
				for (int j = 0; j < hull.size().height; j++) {
					int index = (int)hull.get(j, 0)[0];
					double[] point = new double[] { contour.get(index, 0)[0], contour.get(index, 0)[1]};
					mopHull.put(j, 0, point);
				}
				final double solid = 100 * area / Imgproc.contourArea(mopHull);
				if (solid < solidity[0] || solid > solidity[1]) continue;
				if (contour.rows() < minVertexCount || contour.rows() > maxVertexCount)	continue;
				final double ratio = bb.width / (double)bb.height;
				if (ratio < minRatio || ratio > maxRatio) continue;
				output.add(contour);
			}
		}
		
		////////////// MINE
		
		/**
		 * This method is a getter for the output of the source image
		 * @return Mat output from source
		 */
		public Mat sourceOutput() {
			return sourceOutput;
		}
		
		public ArrayList<int[]> findContourCenters(ArrayList<MatOfPoint> contours) {
			
			ArrayList<Moments> moments = new ArrayList<Moments>(contours.size());
			ArrayList<int[]> centers = new ArrayList<int[]>();
			
			ArrayList<Integer> xcenters = new ArrayList<Integer>(contours.size());
			ArrayList<Integer> ycenters = new ArrayList<Integer>(contours.size());
			
			for(int i = 0; i < contours.size(); i++) {
				moments.add(i, Imgproc.moments(contours.get(i), false));
				Moments p = moments.get(i);
				int[] xy = {(int) (p.get_m10() / p.get_m00()), (int) (p.get_m01() / p.get_m00())};
				centers.add(i, xy);
			}
			
			return centers;
		}
				
		public void drawMyContours(List<MatOfPoint> contours, MatOfPoint goal, Mat img) {
			Scalar c = new Scalar(255, 0, 0, 1);
			Scalar r = new Scalar(0, 0, 255, 1);
			Imgproc.drawContours(img, contours, -1, c, 5);
			
			//Imgproc.rectangle(img, rect.tl(), rect.br(), r, 3);
			//rotated rect
//			Point[] rectPoints = new Point[4];
//	        rect.points(rectPoints);
//	        for (int j = 0; j < 4; j++) {
//	        	Imgproc.line(img, rectPoints[j], rectPoints[(j+1) % 4], r);
//	        }
			if (goal != null) {
				Point[] points = goal.toArray();
				ArrayList<Double> xPoints = new ArrayList<Double>();
				
				for(int i = 0; i < points.length; i++) {
					xPoints.add(i, points[i].x);
				}
				
				Point minPoint = points[xPoints.indexOf(Collections.min(xPoints))];
				Point maxPoint = points[xPoints.indexOf(Collections.max(xPoints))];
				
				Imgproc.line(img, minPoint, maxPoint, r, 3);
			}
		}
		
		public void drawCenters(ArrayList<int[]> centers, Point center, Mat img) {
			
			
			for (int i = 0; i < centers.size(); i++) {
				int[] xy = centers.get(i);
				Point p = new Point(xy[0], xy[1]);	
				Scalar s = new Scalar(0, 255, 0, 1);
				Imgproc.drawMarker(img, p, s);
			}
			Point trueCenter = new Point(321, 241);
			Scalar c = new Scalar(0, 0, 255, 1);
			Imgproc.drawMarker(img, trueCenter, c);
			
			Imgproc.drawMarker(img, center, c);
		}
		
		public ArrayList<MatOfPoint> approxContours(ArrayList<MatOfPoint> contours) {
			
			ArrayList<MatOfPoint2f> contours2F = mopToMOP2F(contours);
			ArrayList<MatOfPoint2f> newContours2F = new ArrayList<MatOfPoint2f>();
			
			for(int i = 0; i < contours.size(); i++) {			
				MatOfPoint2f input = contours2F.get(i);
				MatOfPoint2f output = new MatOfPoint2f();
				
				Imgproc.approxPolyDP(input, output, 3, true);
				
				newContours2F.add(output);
			}
			
			return mop2fToMOP(newContours2F);
		}
		
		
		public ArrayList<MatOfPoint> mop2fToMOP(ArrayList<MatOfPoint2f> mats2f){
			ArrayList<MatOfPoint> mats = new ArrayList<MatOfPoint>();
			
			for(int i = 0; i < mats2f.size(); i++) {
				MatOfPoint temp = new MatOfPoint(mats2f.get(i).toArray());
				mats.add(i, temp);	
			}
			
			return mats;
		}
		
		public ArrayList<MatOfPoint2f> mopToMOP2F(ArrayList<MatOfPoint> mats){
			ArrayList<MatOfPoint2f> mats2f = new ArrayList<MatOfPoint2f>();
			
			for(int i = 0; i < mats.size(); i++) {
				MatOfPoint2f temp = new MatOfPoint2f(mats.get(i).toArray());
				mats2f.add(i, temp);	
			}
			
			return mats2f;
		}
		
//		public static MatOfPoint findGoal(ArrayList<MatOfPoint> contours) {
//			ArrayList<Double> areas = new ArrayList<Double>();
//			MatOfPoint goal = new MatOfPoint();
//			
//			for(int i = 0; i < contours.size(); i++) {
//				double temp = Imgproc.contourArea(contours.get(i));
//				areas.add(i, temp);
//			}
//			
//			if(contours.size() == 0) {
//				goal = null;
//			} else {
//				int indexMinArea = areas.indexOf(Collections.min(areas));
//				goal = contours.get(indexMinArea);
//			}
//			return goal;
//		}
		
		public static MatOfPoint findGoal(ArrayList<MatOfPoint> contours) {
			
			ArrayList<Integer[]> errorPairs = new ArrayList<Integer[]>();
			ArrayList<Double> errors = new ArrayList<Double>();
			
			if(contours.size() == 0) {
				return null;
			}
			
			for(int i = 0; i < contours.size(); i++) {
				for(int j = i + 1; j < contours.size(); j++) {
					Point temp = findGoalCenter(contours.get(i));
					Point otherTemp = findGoalCenter(contours.get(j));
					
					double xError = temp.x - otherTemp.x;
					double yError = temp.y - otherTemp.y;
					
					double totalError = Math.sqrt(Math.pow(xError, 2) + Math.pow(yError, 2));
					
					if(totalError < 10) {					
						Integer[] temps = {i, j};
						errorPairs.add(temps);
						errors.add(totalError);
					}
				}			
			}	
			
			if(errors.size() <= 0) {
				return null;
			} else {
				int lowestErrorLoc = errors.indexOf(Collections.min(errors));
				
				Integer[] temp = errorPairs.get(lowestErrorLoc);
				MatOfPoint cont1 = contours.get(temp[0]);
				MatOfPoint cont2 = contours.get(temp[1]);
				
				if(Imgproc.contourArea(cont1) < Imgproc.contourArea(cont2)) {
					return cont1;
				} else {
					return cont2;
				}
			}
		}
		
//		public static RotatedRect findGoalRect(MatOfPoint goal) {
//			RotatedRect goalRect = new RotatedRect();
//			
//			if(goal == null) {
//				goalRect = null;
//			} else {
//				MatOfPoint2f temp = new MatOfPoint2f(goal.toArray());
//				goalRect = Imgproc.minAreaRect(temp);
//			}
//			return goalRect;
//		}
//		
//		public static double findGoalRectWidth(MatOfPoint goal) {
//			RotatedRect goalRect = new RotatedRect();
//			
//			if(goal == null) {
//				goalRect = null;
//			} else {
//				MatOfPoint2f temp = new MatOfPoint2f(goal.toArray());
//				goalRect = Imgproc.minAreaRect(temp);
//			}
//			return goalRect.size.width;
//		}
		
//		public static Rect findGoalRect(MatOfPoint goal) {
//			Rect goalRect = new Rect();
//			
//			if(goal == null) {
//				goalRect = null;
//			} else {
//				goalRect = Imgproc.boundingRect(goal);
//			}
//			return goalRect;
//		}
		
		public static double findGoalWidth(MatOfPoint goal) {
//			Rect goalRect = new Rect();
//			
//			if(goal == null) {
//				goalRect = null;
//			} else {
//				goalRect = Imgproc.boundingRect(goal);
//			}
//			return goalRect.width;
			
			if(goal == null) {
				return 0;
			} else {
				Point[] points = goal.toArray();
				ArrayList<Double> xPoints = new ArrayList<Double>();
				
				for(int i = 0; i < points.length; i++) {
					xPoints.add(i, points[i].x);
				}
				
				Point minPoint = points[xPoints.indexOf(Collections.min(xPoints))];
				Point maxPoint = points[xPoints.indexOf(Collections.max(xPoints))];
				
				double width = Math.sqrt(Math.pow((minPoint.x - maxPoint.x), 2) + Math.pow((minPoint.y - maxPoint.y), 2));
				return width;
			}			
		}
		
//		public static double findGoalArea(ArrayList<MatOfPoint> contours) {
//			ArrayList<Double> areas = new ArrayList<Double>();
//			double area;
//			
//			for(int i = 0; i < contours.size(); i++) {
//				double temp = Imgproc.contourArea(contours.get(i));
//				areas.add(i, temp);
//			}
//			
//			if(contours.size() == 0) {
//				area = 0;
//			} else {
//				area = Collections.min(areas);
//			}
//			return area;
//		}
		
		public static double distanceToCamera(double knownWidth, double focalLength, double pixWidth) {			
			return (knownWidth * focalLength) / pixWidth;
		}
		
		public static double focalLength() {
//			double knownDistance = 80;
//			double knownWidth = 34.5;
//			double pixWidth = findGoalWidth(goal);
//			double focalLength = (pixWidth * knownDistance) / knownWidth;
//			
//			System.out.println(focalLength);
//			return focalLength;
			return 796.507393917613;
		}
		
		public static double goalDistance(MatOfPoint goal) {
			double distance;
			
			if(goal == null) {
				distance = 0;
			} else {
				double knownWidth = 34.5;
				double width = findGoalWidth(goal);
				double focalLength = focalLength();
				distance = distanceToCamera(knownWidth, focalLength, width);
			}
					
			return distance;
		}
		
		public static double pixToInch(double pixWidth, double distance) {	
			double focalLength = focalLength();
			return (pixWidth * distance) / focalLength;		
		}
		
		public static Point findGoalCenter(MatOfPoint goal) {
			
			if(goal != null) {
				Moments moments = Imgproc.moments(goal);
				int xCenter = (int) (moments.get_m10() / moments.get_m00());
				int yCenter = (int) (moments.get_m01() / moments.get_m00());
				Point center = new Point(xCenter, yCenter);
					
				return center;
			}
			
			return new Point(321, 241);
		}
		
		public static double findXAngle(MatOfPoint goal) {
			//sin(z) = pixToInch(target from center) / distance in inches
						
			Point centerPoint = findGoalCenter(goal);
			Point trueCenter = new Point(321, 241);
			
			double pixDistFromCenter = centerPoint.x - trueCenter.x;
			
			return Math.toDegrees(Math.asin((pixToInch(pixDistFromCenter, goalDistance(goal))/ goalDistance(goal))));
		}
		
		public double getXAngle() {
			return findXAngle(findGoal(filterContoursOutput()));
		}
		
}

